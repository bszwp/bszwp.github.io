---
layout: post
title: "前端面试题总结 - 高频"
date: 2016-11-02
tags: 博客
---



[TOC]

#### 1.JS数据类型

基本数据类型(简单数据类型) : Undefined、Null、Boolean、Number、String

引用数据类型：Object

参考: 	http://www.jb51.net/article/71549.htm

​		http://www.cnblogs.com/leezhxing/p/4103893.html



#### 2.AMD与CMD

AMD (Asynchronous Module Definition，异步模块定义) 是 RequireJS 在推广过程中对模块定义的规范化产出。
CMD (Common Module Definition，同步模块定义)是 SeaJS 在推广过程中对模块定义的规范化产出。

1. 对于依赖的模块，AMD 是**提前执行**，CMD 是**延迟执行**。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible.
2. CMD 推崇**依赖就近**，AMD 推崇**依赖前置**。eg:

```javascript
// CMD
define(function(require, exports, module) {
    var a = require('./a')
    a.doSomething()
    // 此处略去 100 行
    var b = require('./b') // 依赖可以就近书写
    b.doSomething()
    // ...
})

// AMD 默认推荐的是
define(['./a', './b'], function(a, b) { // 依赖必须一开始就写好
    a.doSomething()
    // 此处略去 100 行
    b.doSomething()
    // ...
})
```

虽然 AMD 也支持 CMD 的写法，同时还支持将 require 作为依赖项传递，但 RequireJS 的作者默认是最喜欢上面的写法，也是官方文档里默认的模块定义写法。

    3. AMD 的 API 默认是一个当多个用，CMD 的 API 严格区分，推崇职责单一。比如 AMD 里，require 分全局 require 和局部 require，都叫 require。CMD 里，没有全局 require，而是根据模块系统的完备性，提供 seajs.use 来实现模块系统的加载启动。CMD 里，每个 API 都简单纯粹。

    4. 还有一些细节差异，具体看这个规范的定义就好，就不多说了。

另外，SeaJS 和 RequireJS 的差异，可以参考：[https://github.com/seajs/seajs/issues/277](https://github.com/seajs/seajs/issues/277) 



参考: 	[JavaSript模块规范 - AMD规范与CMD规范介绍](http://blog.chinaunix.net/uid-26672038-id-4112229.html) 



#### 3.闭包的理解

当在函数内部定义了其他函数时候，就创建了闭包。闭包有权访问包含函数内部的所有变量。通过闭包，可以实现外部访问函数局部内的变量。

闭包可以延长变量的生命周期。通常函数的作用域即变量会在函数执行结束后被销毁，但当函数返回一个闭包，只要闭包不被释放，整条作用域链都会占用内存。

**闭包的特性：**

①.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口
②.持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在
系统中，闭包中的数据依然存在，从而实现对数据的持久使用。

**优点：**

① 减少全局变量。

② 减少传递函数的参数量

③ 封装；

**缺点：**
使用闭包会占有内存资源，过多的使用闭包会导致内存溢出等.



参考:	[让你一句话理解闭包(简单易懂)](http://www.jb51.net/article/85775.htm)

​		[javascript闭包概念简单解析(推荐)](http://www.jb51.net/article/85776.htm)



#### 4.call和apply的区别

**call方法:** 
语法：call(thisObj，...args)
定义：调用一个对象的一个方法，以另一个对象替换当前对象。
说明：
call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。 
如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 

**apply方法：** 
语法：apply(thisObj，[argArray])
定义：应用某一对象的一个方法，用另一个对象替换当前对象。 
说明： 
如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。 
如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。



1、call，apply都属于Function.prototype的一个方法，它是JavaScript引擎内在实现的，因为属于Function.prototype，所以每个Function对象实例(就是每个方法)都有call，apply属性。既然作为方法的属性，那它们的使用就当然是针对方法的了，这两个方法是容易混淆的，因为它们的作用一样，只是使用方式不同。

2、语法：foo.call(this, arg1,arg2,arg3) == foo.apply(this, [argArray]) == this.foo(arg1, arg2, arg3);

3、相同点：两个方法产生的作用是完全一样的。

4、不同点：方法传递的参数不同。



参考:	[javascript中apply和call方法的作用及区别说明](http://www.jb51.net/article/46789.htm) 



#### 5.原型与原型链的理解

prototype是构造函数的属性，指的就是构造函数的原型，在生成实例的时候，js会根据构造函数的prototype属性将该属性下的对象生成为父类。

注意，只有构造函数这个属性才有这种效果哦~如果一个构造函数没有指定该属性，那么该属性下的__proto__会默认的指向原生Object的原型对象,该属性会变成一个对象，其中constructor属性指向本身。

**constructor**

   constructor，如果通俗的理解，可以理解成原型对象的构造函数，当把一个对象（对象字面量）赋给一个构造函数的原型，constructor 会被复写，如果没有进行prototype的操作的话，constructor是函数声明时指定的，指定为本身。

__\_\_proto\_\___

可以这么说，js的原型链就是通过这个属性串联起来的，\_\_proto\_\_属性指向他的父类，在调用一个对象的属性或者方法的时候就是通过\_\_proto\_\_这一属性指向的对象一层一层的向上查找的。上面的一句：**在生成实例的时候，js会根据构造函数的prototype属性将该属性下的对象生成为父类,在这里可以改为，在生成实例的时候，js会根据构造函数的prototype属性将该属性下的对象引用到实例的\_\_proto\_\_属性下**。

**继承**

继承是面向对象语言的重要机制，通俗地讲就是子类可以拥有父类的方法和属性，js的原型链实际上也是一种继承，在ECMAScript标准中，只支持实现继承，而其实现实现继承就是主要依靠于原型链实现的。

**原型**

原型其实就是上述所说的继承中的父类。

**原型链**

可以理解为，利用原型串起一个继承链，让一个引用类型继承另一个引用类型的属性和方法，再以此类推下去.

**构造函数，原型，与实例的关系**

这三者的关系用一句话概括为，每个构造函数都有一个原型，当new 一个构造函数的时候就会生成一个原型链上携带该构造函数的原型的实例。

 参考:	[深度理解原型链](http://blog.csdn.net/leadn/article/details/51781539) 

​		[一个例子让你彻底明白原型对象和原型链](http://www.jianshu.com/p/aa1ebfdad661)

​		[个人对"原型"和"原型链"的理解](http://blog.csdn.net/cuiyh1993/article/details/47011259)



#### 6.CSS3 Transform / Transition / Animation 属性的区别

**transform** 变形，属性是静态属性，一旦写到style里面，将会直接显示作用，无任何变化过程。

属性则有以下五个：

- `translate3d(x,y,z)` 是用来控制元素的位置在页面上的三轴的位置的；
- `rotate(deg)`是用来控制元素旋转角度的；
- `skew[x,y](deg)` 这个属性是用来制作倾斜度的，做过设计的人可能会知道，这个是用来在2d里面创建3d透视图的时候必须的属性；
- `scale3d(x,y,z)` 用来放大缩小效果，属性是比值；
- `matrix3d`，css矩阵。通过这个矩阵属性，涵盖了上面所有的属性值，但是个人觉得可读性极差（全都是数字和单位，背起来有点模糊），目前没有理由推荐使用。

**transition** 过渡，可以说它是animation的简化版本，是给普通做简单网页特效用的。比如你有如下两个样式：

```css
.position{
    left:100px;
    top:100px;
}
.animate{
    transition:left 0.5s ease-out;
    left:500px;
    top:500px;
}
```

**animation** 动画，这个属性是transition属性的扩展。但是这个简单的介绍里面包含了不简单的东西：`keyframes`。

```css
@keyframes 'wobble'{
  0%{
   left:100px
}
   30%{
   left:300px;
}
  100%{
   left:500px;
}
}
.animate{
	left:100px;
   -webkit-animation:wobble 0.5s ease-out;
   -webkit-animation-fill-mode:backwards;
}
```

参考:	[CSS Transform / Transition / Animation 属性的区别](http://www.cnblogs.com/aimyfly/p/3195898.html) 





#### 7.如何阻止事件冒泡和默认事件？

原生

**1.event.stopPropagation()** 阻止事件的冒泡方法

**2.event.preventDefault()** 阻止默认事件的方法

**3.return false ；** 同事阻止事件冒泡也会阻止默认事件

jquery

eg:

```javascript
$(".box a").click(function(event){
	event.preventDefault();
})；
```



参考:	[阻止事件冒泡，阻止默认事件，event.stopPropagation()和event.preventDefault()，return fal的区别](http://blog.csdn.net/wxl1555/article/details/53128966) 



#### 8.document.write和innerHTML的区别？

document.write是直接将内容写入页面中，会导致页面全部重绘，innerHTML将内容写入某个DOM节点，不会导致页面全部重绘



#### 9.重绘与回流(repaint和reflow)

参考:	[reflow（回流）和repaint（重绘）及其优化](http://blog.csdn.net/claireke/article/details/51375622) 



#### 10.js继承的几种方式

参考:	[JS继承的实现方式](http://www.cnblogs.com/humin/p/4556820.html)



#### 11.HTTP协议

参考:	[关于HTTP协议，一篇就够了](http://www.cnblogs.com/ranyonsue/p/5984001.html) 

​		[HTTP 协议入门](http://www.ruanyifeng.com/blog/2016/08/http.html) 